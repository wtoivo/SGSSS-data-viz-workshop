# Introduction

Welcome to the SGSSS Summer School workshop on data visualisation! In today's session, we are going to cover:

- The basic principles of data visualisation;

- A very brief overview of setting up and getting started on RStudio;

- The structure of the ggplot2 data visualisation package with different customisation options;

- Four different types of plots for four different types of data social science researchers are likely to encounter (bar plots for count data, scatterplots for correlational data, violin-boxplots for distributions, and line plots for time series data).

This workshop is based on PsyTeachR materials with some changes and additions specific to this workshop. The materials have been adapted from:

Nordmann, E. & DeBruine, L. (2022). Applied Data Skills (1.0). Zenodo. https://doi.org/10.5281/zenodo.6365078

Nordmann, E., McAleer, P., Toivo, W., Paterson, H. & DeBruine, L. (2022). Data visualisation using R, for researchers who don't use R. *Advances in Methods and Practices in Psychological Science*, 5(2), 1-36. https://doi.org/10.1177/25152459221074654

A more comprehensive version of this tutorial can be found here: https://psyteachr.github.io/introdataviz/index.html

## Data visualisation principles

Before we explore the practical side of R, we want to cover some principles behind effective data visualisation. Its useful to think about where and for whom graphs are useful. Graphs help across all research stages, from understanding your data in exploratory data analysis, to communicating your key message to your readers. However, while effective data visualisation can help to communicate your findings, it is easy to confuse or potentially mislead your readers through poorly designed graphs. These skills take time to develop and there may not always be a general rule to follow, so it is important to recognise your role as the analyst as you will always have decisions to make. 

### Graphs for you 

Even if you never show a graph to your reader, exploratory data analysis is a crucial step of any research project. As you move from reading to cleaning to modelling your data, quickly making plots can help you to understand any underlying patterns. If you solely rely on statistical summaries, you may not notice these patterns. 

One famous example is called Anscombe's quartet where four variable pairs have the same statistical summary (a correlation of *r* = .82) but come from very different underlying patterns. The plot grid below demonstrates a scatterplot of all four pairs where you can see the line of best fit is identical. If you only relied on the correlation, you would not recognise a linear relationship is only appropriate for the first pair. 

In our demonstrations, we will cover different customisation options, but you should be able to create quick plots like these in only two or three lines of code to form a key part of your data analysis toolkit. 

```{r anscombes quartet, echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
library(cowplot)

p1 <- ggplot(anscombe, aes(x1, y1)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE)

p2 <- ggplot(anscombe, aes(x2, y2)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE)

p3 <- ggplot(anscombe, aes(x3, y3)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE)

p4 <- ggplot(anscombe, aes(x4, y4)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE)

plot_grid(plotlist = list(p1, p2, p3, p4))

```

### Graphs for your reader

When it is time to create visualisations for the benefit of your reader, graphs are capable of communicating your message faster and more effectively than any written summary. But it is important to balance efficiency with transparency about the underlying data. As we saw with Anscombe's quartet, simple summaries can mask more complicated problems. 

For example, you will often see bar plots in journal articles to show the difference between groups or conditions. Bar plots are great for displaying frequencies but when they are used to represent continuous data they can hide important details about the underlying data (see [Weissgerber et al., 2015](https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1002128)). The graphs below show a regular bar plot and then with the data superimposed. In the left plot, the two patterns of data look almost identical, but in the right plot, you can see they come from very different underlying distributions. 

```{r barbarplots, echo = FALSE, warning=FALSE, message=FALSE}
set.seed(68493)

A <- data.frame(
  Group = "A",
  DV = rnorm(1000, 0.17, 0.04))

B <- data.frame(
  Group = "B",
  DV = rbeta(1000, 2, 10))

data <- rbind(A, B)

p1 <- ggplot(data, aes(x = Group, y = DV)) + 
  geom_bar(stat = "summary", fun.y = "mean")

p2 <- ggplot(data, aes(x = Group, y = DV)) + 
  geom_bar(stat = "summary", fun.y = "mean") + 
  geom_jitter(width = 0.2, alpha = 0.5)

plot_grid(plotlist = list(p1, p2), nrow = 1, ncol = 2)
  
```

Your role as the data analyst is key here as what might be important in one type of plot or for one audience might be different in another context. It will be down to you to choose the type of plot you think is best suited to the data you are working with and the design features you choose to emphasise such as the underlying data or the comparisons you want your readers to focus on.

In the following sections, we provide a brief overview of different kinds of principles and design features to keep in mind before we introduce you to creating different plots in R later in the workshop. We could easily spend the whole workshop covering good and bad plot design, so we recommend chapter one - looking at data - from [Data Visualisation](https://socviz.co/index.html#preface) by Healy (2018) and the comprehensive journal article [The Science of Visual Data Communication: What Works](https://doi.org/10.1177/15291006211051956) by Franconeri et al. (2021) for further reading. 

### Common visual illusions 

Your visual system is pretty powerful and allows you to rapidly search for patterns in visual information. But for the same reasons that make graphs effective at communicating information, design features can also play tricks on the visual system and create illusions. 

#### Y-axis truncation

One of the most powerful and most common illusions that can mislead people is truncated or non-zero axes, where (typically) the y-axis is shortened to zoom in on a smaller range of values. Franconeri et al. (2021) discuss studies that show people overestimate differences between two groups when you tell them the truncation is present and even if you get people to manually enter the average values from each group. For example, the bar plot below shows the same difference across the full 0 to 100 scale, then truncated between 45 and 60 to highlight the difference. 

```{r y axis trunc}
set.seed(68493)

A <- data.frame(
  Group = "A",
  DV = rnorm(1000, 50, 20))

B <- data.frame(
  Group = "B",
  DV = rnorm(1000, 55, 20))

data <- rbind(A, B)

p1 <- ggplot(data, aes(x = Group, y = DV)) + 
  geom_bar(stat = "summary", fun.y = "mean") + 
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 25))

p2 <- ggplot(data, aes(x = Group, y = DV)) + 
  geom_bar(stat = "summary", fun.y = "mean") + 
  coord_cartesian(ylim = c(45, 60))

plot_grid(plotlist = list(p1, p2), nrow = 1, ncol = 2)
```

This is another area where it takes time and experience to recognise where y-axis trunctation is misleading or not. Although we are not trying to turn this into a bar plot witch hunt, as a general rule of thumb, its usually not a good idea to truncate the y-axis of a bar plot as they are meant to display frequencies with a logical zero point. On the other hand, its acceptable to truncate line plots (chapter 6) as they are designed to show changes across time. For further information on the nuances, see [Correll et al. (2020)](http://arxiv.org/abs/1907.02035) who discuss when y-axis truncation is honest or deceptive. 

#### Colour-vision impairments

One important design feature is how you will distinguish between different elements of your graph. Colour can be used to effectively code different groups or conditions, but many analysts do not think carefully about colour combinations. Colour-vision impairments affect a significant number of people, so it is important to consider whether someone who is colour blind could distinguish between groups/conditions and understand the message you are trying to communicate. In the plot below, on the top is a scatterplot using green and purple, which can look identical for some types of colourblind. On the bottom is the same scatterplot using a colour blind friendly palette of greens. 

Fortunately, it is easy to choose colour blind friendly combinations as the package we will be using comes with different palette options designed to be easier to read with colourblindness and that you can print it in greyscale. We will demonstrate how you can do this in chapter three. 

```{r different colour schemes, echo=FALSE, message=FALSE, warning=FALSE}

dat <- read_csv(file = "ldt_data.csv")

dat_clean <- pivot_longer(data = dat, 
                         cols = rt_word:acc_nonword, 
                         names_sep = "_", 
                         names_to = c("dv_type", "condition"),
                         values_to = "dv") %>%
  pivot_wider(names_from = "dv_type", 
              values_from = "dv") %>% 
  mutate(condition=as.factor(condition), language=as.factor(language))

p1 <- ggplot(dat_clean, aes(x = rt, y = acc, colour = condition)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_colour_discrete(name = "Condition",
                        labels = c("Non-Word", "Word"), type = c("purple", "limegreen"))

p2 <- ggplot(dat_clean, aes(x = rt, y = acc, colour = condition)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_colour_viridis_d(option="D", begin = 0.4, end = 0.8, name = "Condition",
                        labels = c("Non-Word", "Word"))

plot_grid(plotlist = list(p1, p2), nrow = 2, ncol = 1)

```

### Highlight comparisons of interest

### Integrate relevant text

### Use formats familiar to your audience

### Guide views to your conceptual message

## Why use R for data visualisation?

Creating data visualisations by writing code (as opposed to using point-and-click software) increases the reproducibility of your work. If you write code to produce your plots, you can reuse and adapt that code in the future. Finally, using R to create data visualisations gives you control over basically every element of your plot.

We hope that this workshop will inspire you to start experimenting with R! In today's session we are simply focusing on visualisation and don't really touch on data wrangling (which is the most time-consuming part of any data analysis). The data you will encounter in the wild will be messier than what you see today - it's perfectly acceptable to start by cleaning your data on software that you feel more comfortable with and simply reading the clean data into R for visualisation. However, we do recommend eventually moving onto doing all parts of the analysis in R for the reproducibility benefits outlined above. If you want to dip your toes into data wrangling, the PsyTeachR team have a wealth of materials for different levels of expertise freely available online: https://psyteachr.github.io/ 

## A very short introduction to R

### Installing R

If you don't have R and RStudio installed, please follow the instructions here: https://emilynordmann.github.io/workshop-dataviz/installing-r.html

Alternatively, you can create a free profile for RStudio Cloud: https://rstudio.cloud/

### What are R and RStudio?

R is a programming language that you will write code in and RStudio is an Integrated Development Environment (IDE), which makes working in R easier. You can use R without R Studio but we wouldn't recommend it. RStudio serves as a text editor, file manager, spreadsheet viewer, and more. The key thing to remember is that you are actually using two pieces of software, which means that from time-to-time, both of them may have separate updates.

#### RStudio

By default, RStudio is arranged with four window panes.

```{r img-rstudio, echo=FALSE, fig.cap="The RStudio IDE"}
knitr::include_graphics("images/intro/rstudio.png")
``` 

The upper left pane is the **source pane**, where you view, write, and edit code from files and view data in a spreadsheet format. When you first open RStudio, this pane won't display until we open a document or load in some data.

The lower left pane is the **console pane**, where you can type in commands and view output messages. You can write code in the console to test it out, but it won't be saved! You need to write your code into a script in the source pane to save it.

The right panes have several different tabs that show you information about your code. The most used tabs in the upper right pane are the **Environment tab** and the **Help tab**. The environment tab lists some information about the objects that you have defined in your code.

In the lower right pane, the most used tabs are the **Files** tab for directory structure, the **Plots** tab for plots made in a script, the **Packages** tab for managing add-on packages, and the **Viewer** tab to display reports created by your scripts. You can change the location of panes and what tabs are shown under Preferences > Pane Layout.

### Functions

When you install R you will have access to a range of functions including options for data wrangling and statistical analysis. The functions that are included in the default installation are typically referred to as base R, and you can think of them like the default apps that come pre-loaded on your phone. 

If you type a function into the console pane, it will run as soon as you hit enter. If you put the function in a script or R Markdown document, it won't run until you run the code.

For example, the function `sum()` is included in base R. In the console, run the below code:

```{r sum example}
sum(1,2,3)
```

### Arguments 

Most functions require you to specify arguments in them. Arguments are basically you telling the function how you want it to run. As an example, look at the help documentation for the function `sample()` which randomly samples items from a list. 

```{r help-doc, eval=FALSE}
?sample
```

The help documentation for `sample()` should appear in the bottom right help panel. We see that `sample()` takes the following form:

```{r arguments, eval = FALSE}
sample(x, size, replace = FALSE, prob = NULL)
```

In the arguments section, there are explanations for each of the arguments. `x` is the list of items we want to choose from, `size` is the number of items we want to choose, `replace` is whether or not each item may be selected more than once, and `prob` gives the probability that each item is chosen. 

In the details section it notes that if no values are entered for `replace` or `prob` it will use defaults of `FALSE` (each item can only be chosen once) and `NULL` (all items will have equal probability of being chosen). Because there is no default value for `x` or `size`, they must be specified otherwise the code won't run.

Let's try an example and just change the required arguments to `x` and `size` to ask R to choose 5 random letters (`letters` is a built-in vector - a sequence of data - of the 26 lower-case Latin letters). 

```{r sample-n}
sample(x = letters, size = 5)
```

### Objects

Objects are things you create in your code, and they can contain different things such as numbers, words, results of analyses, or dataframes. A large part of your coding will involve creating and manipulating objects. You assign content to an object using `<-`.

Run the following code in the console:

```{r object examples}
test <- "potato"

summed <- 1+2

```

Try to create an object called `name` and enter your name, and an object called `age` and add your age.

### Packages

Packages are add-ons which allow you to access different functions that are not included in base R. This is done using `install.packages()`. This is like installing an app on your phone: you only have to do it once and the app will remain installed until you remove it. Once you launch the app, it will run in the background until you close it or restart your phone. Likewise, when you install a package, the package will be available (but not loaded) every time you open up R.

This tutorial will require you to use the `ggplot2` package, which is a part of the `tidyverse` collection. To install it, copy and paste the below code into the console (the bottom left hand pane) and press enter to execute the code.

```{r packages, eval = FALSE}
# type this in the console pane, never in a script or an R Markdown (.RMd) file!
install.packages("tidyverse")
```

You should always install packages in the console and never in a script - leaving this code in your script can lead you to unintentionally install a package update you didn't want. For this reason, avoid including install code in any script or Markdown document.
